# 一款简单的基于 Redis 分布式限流插件

## 限流算法

### 固定窗口算法

使用固定窗口实现限流的思路大致为：将某一个时间段当做一个窗口，在这个窗口内存在一个计数器记录这个窗口接收请求的次数，

每接收一次请求便让这个计数器的值加一,如果计数器的值大于请求阈值的时候，即开始限流。 当这个时间段结束后，会初始化窗口的计数器数据，相当于重新开了一个窗口重新监控请求次数。

缺点：

固定窗口可以对一段时间的流量进行监控，但是有一个致命的问题，就是我们监控流量都是指时间段而不是具体的某一个时间，

假设我们的窗口时间为一分钟，当一分钟后会切换到另外一个窗口重新监控。这个切换就有可能出现问题。

假设我们在第一个窗口的最后十秒发了100个请求，在第二个窗口开始的时候也可以发100个请求，那么在这二十秒时间内服务器就会接收到200个请求，这样很有可能会使服务器接收的请求过多而挂掉。所以就出现了固定窗口的优化版，滑动窗口来解决这个问题。

### 滑动窗口算法

滑动窗口为固定窗口的改良版，解决了固定窗口在窗口切换时会受到两倍于阈值数量的请求，滑动窗口在固定窗口的基础上，

将一个窗口分为若干个等份的小窗口，每个小窗口对应不同的时间点，拥有独立的计数器，当请求的时间点大于当前窗口的最大时间点时，

则将窗口向前平移一个小窗口（将第一个小窗口的数据舍弃，第二个小窗口变成第一个小窗口，当前请求放在最后一个小窗口），整个窗口的所有请求数相加不能大于阀值。

### 漏桶算法

漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了。

这种算法很简单，但也非常粗暴，无法应对突发的大流量。 这时可以考虑令牌桶算法。

### 令牌桶算法

![令牌桶算法-来自网络.gif](https://i.loli.net/2017/08/11/598c91f2a33af.gif)

令牌桶算法是按照恒定的速率向桶中放入令牌，每当请求经过时则消耗一个或多个令牌。当桶中的令牌为 0 时，请求则会被阻塞。

> note：
令牌桶算法支持先消费后付款，比如一个请求可以获取多个甚至全部的令牌，但是需要后面的请求付费。也就是说后面的请求需要等到桶中的令牌补齐之后才能继续获取。

## 拓展使用 Redis 限流

### 注入 StringRedisTemplate 及 RedisScript

```
@Bean
public StringRedisTemplate stringRedisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
    StringRedisTemplate template = new StringRedisTemplate();
    template.setConnectionFactory(lettuceConnectionFactory);
    return template;
}
```

```
@Bean
public DefaultRedisScript<Boolean> redisRateLimiterScript() {
    DefaultRedisScript<Boolean> defaultRedisScript = new DefaultRedisScript<>();
    defaultRedisScript.setResultType(Boolean.class);
    defaultRedisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("META-INF/scripts/request_rate_limiter.lua")));
    return defaultRedisScript;
}
```

### 编写 lua 脚本

参考 spring-cloud-gateway

```lua
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 李俊平.
--- DateTime: 2022/8/25 14:49
---

local tokens_key = KEYS[1]
local timestamp_key = KEYS[2]
--redis.log(redis.LOG_WARNING, "tokens_key " .. tokens_key)

local rate = tonumber(ARGV[1])
local capacity = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4])

local fill_time = capacity/rate
local ttl = math.floor(fill_time*2)

--redis.log(redis.LOG_WARNING, "rate " .. ARGV[1])
--redis.log(redis.LOG_WARNING, "capacity " .. ARGV[2])
--redis.log(redis.LOG_WARNING, "now " .. ARGV[3])
--redis.log(redis.LOG_WARNING, "requested " .. ARGV[4])
--redis.log(redis.LOG_WARNING, "filltime " .. fill_time)
--redis.log(redis.LOG_WARNING, "ttl " .. ttl)

local last_tokens = tonumber(redis.call("get", tokens_key))
if last_tokens == nil then
    last_tokens = capacity
end
--redis.log(redis.LOG_WARNING, "last_tokens " .. last_tokens)

local last_refreshed = tonumber(redis.call("get", timestamp_key))
if last_refreshed == nil then
    last_refreshed = 0
end
--redis.log(redis.LOG_WARNING, "last_refreshed " .. last_refreshed)

local delta = math.max(0, now-last_refreshed)
local filled_tokens = math.min(capacity, last_tokens+(delta*rate))
local allowed = filled_tokens >= requested
local new_tokens = filled_tokens
local allowed_num = 0
if allowed then
    new_tokens = filled_tokens - requested
    allowed_num = 1
end

--redis.log(redis.LOG_WARNING, "delta " .. delta)
--redis.log(redis.LOG_WARNING, "filled_tokens " .. filled_tokens)
--redis.log(redis.LOG_WARNING, "allowed_num " .. allowed_num)
--redis.log(redis.LOG_WARNING, "new_tokens " .. new_tokens)

if ttl > 0 then
    redis.call("setex", tokens_key, ttl, new_tokens)
    redis.call("setex", timestamp_key, ttl, now)
end

-- return { allowed_num, new_tokens, capacity, filled_tokens, requested, new_tokens }
return { allowed_num, new_tokens }

```

成杰

```lua
--
-- Created by IntelliJ IDEA.
-- User: crossoverJie
-- Date: 22/04/2018
-- Time: 15:36
-- To change this template use File | Settings | File Templates.
--
--lua 下标从 1 开始
-- 限流 key
local key = KEYS[1]
-- 限流大小
local limit = tonumber(ARGV[1])

-- 获取当前流量大小
local curentLimit = tonumber(redis.call('get', key) or "0")

if curentLimit + 1 > limit then
    -- 达到限流大小 返回
    return 0;
else
    -- 没有达到阈值 value + 1
    redis.call("INCRBY", key, 1)
    redis.call("EXPIRE", key, 2)
    return curentLimit + 1
end
```

network

```lua
--利用redis的hash结构，存储key所对应令牌桶的上次获取时间和上次获取后桶中令牌数量
local ratelimit_info = redis.pcall('HMGET',KEYS[1],'last_time','current_token_num')
local last_time = ratelimit_info[1]
local current_token_num = tonumber(ratelimit_info[2])

redis.replicate_commands()
local now = redis.call('time')[1]
redis.call('SET','now',now);



--tonumber是将value转换为数字，此步是取出桶中最大令牌数、生成令牌的速率(每秒生成多少个)、当前时间
local max_token_num = tonumber(ARGV[1])
local token_rate = tonumber(ARGV[2])
--local current_time = tonumber(ARGV[3])
local current_time = now
--reverse_time 即多少毫秒生成一个令牌
local reverse_time = 1000/token_rate

--如果current_token_num不存在则说明令牌桶首次获取或已过期，即说明它是满的
if current_token_num == nil then
  current_token_num = max_token_num
  last_time = current_time
else
  --计算出距上次获取已过去多长时间
  local past_time = current_time-last_time
  --在这一段时间内可产生多少令牌
  local reverse_token_num = math.floor(past_time/reverse_time)
  current_token_num = current_token_num +reverse_token_num
  last_time = reverse_time * reverse_token_num + last_time
  if current_token_num > max_token_num then
    current_token_num = max_token_num
  end
end

local result = 0
if(current_token_num > 0) then
  result = 1
  current_token_num = current_token_num - 1
end

--将最新得出的令牌获取时间和当前令牌数量进行存储,并设置过期时间
redis.call('HMSET',KEYS[1],'last_time',last_time,'current_token_num',current_token_num)
redis.call('pexpire',KEYS[1],math.ceil(reverse_time*(max_token_num - current_token_num)+(current_time-last_time)))

return result
```
