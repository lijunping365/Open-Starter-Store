# 一款简单的基于 Redis 分布式限流插件

## 限流算法

### 固定窗口算法

使用固定窗口实现限流的思路大致为：将某一个时间段当做一个窗口，在这个窗口内存在一个计数器记录这个窗口接收请求的次数，

每接收一次请求便让这个计数器的值加一,如果计数器的值大于请求阈值的时候，即开始限流。 当这个时间段结束后，会初始化窗口的计数器数据，相当于重新开了一个窗口重新监控请求次数。

缺点：

固定窗口可以对一段时间的流量进行监控，但是有一个致命的问题，就是我们监控流量都是指时间段而不是具体的某一个时间，

假设我们的窗口时间为一分钟，当一分钟后会切换到另外一个窗口重新监控。这个切换就有可能出现问题。

假设我们在第一个窗口的最后十秒发了100个请求，在第二个窗口开始的时候也可以发100个请求，那么在这二十秒时间内服务器就会接收到200个请求，这样很有可能会使服务器接收的请求过多而挂掉。所以就出现了固定窗口的优化版，滑动窗口来解决这个问题。

### 滑动窗口算法

滑动窗口为固定窗口的改良版，解决了固定窗口在窗口切换时会受到两倍于阈值数量的请求，滑动窗口在固定窗口的基础上，

将一个窗口分为若干个等份的小窗口，每个小窗口对应不同的时间点，拥有独立的计数器，当请求的时间点大于当前窗口的最大时间点时，

则将窗口向前平移一个小窗口（将第一个小窗口的数据舍弃，第二个小窗口变成第一个小窗口，当前请求放在最后一个小窗口），整个窗口的所有请求数相加不能大于阀值。

### 漏桶算法

漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了。

这种算法很简单，但也非常粗暴，无法应对突发的大流量。 这时可以考虑令牌桶算法。

### 令牌桶算法

![令牌桶算法-来自网络.gif](https://i.loli.net/2017/08/11/598c91f2a33af.gif)

令牌桶算法是按照恒定的速率向桶中放入令牌，每当请求经过时则消耗一个或多个令牌。当桶中的令牌为 0 时，请求则会被阻塞。

> note：
令牌桶算法支持先消费后付款，比如一个请求可以获取多个甚至全部的令牌，但是需要后面的请求付费。也就是说后面的请求需要等到桶中的令牌补齐之后才能继续获取。

## 拓展使用 Redis 限流

### 注入 StringRedisTemplate 及 RedisScript

```
@Bean
public StringRedisTemplate stringRedisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {
    StringRedisTemplate template = new StringRedisTemplate();
    template.setConnectionFactory(lettuceConnectionFactory);
    return template;
}
```

```
@Bean
public DefaultRedisScript<Boolean> redisRateLimiterScript() {
    DefaultRedisScript<Boolean> defaultRedisScript = new DefaultRedisScript<>();
    defaultRedisScript.setResultType(Boolean.class);
    defaultRedisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("META-INF/scripts/request_rate_limiter.lua")));
    return defaultRedisScript;
}
```

### 编写 lua 脚本

参考 spring-cloud-gateway

```lua
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 李俊平.
--- DateTime: 2022/8/25 14:49
---

local tokens_key = KEYS[1]
local timestamp_key = KEYS[2]
--redis.log(redis.LOG_WARNING, "tokens_key " .. tokens_key)

local rate = tonumber(ARGV[1])
local capacity = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4])

local fill_time = capacity/rate
local ttl = math.floor(fill_time*2)

--redis.log(redis.LOG_WARNING, "rate " .. ARGV[1])
--redis.log(redis.LOG_WARNING, "capacity " .. ARGV[2])
--redis.log(redis.LOG_WARNING, "now " .. ARGV[3])
--redis.log(redis.LOG_WARNING, "requested " .. ARGV[4])
--redis.log(redis.LOG_WARNING, "filltime " .. fill_time)
--redis.log(redis.LOG_WARNING, "ttl " .. ttl)

local last_tokens = tonumber(redis.call("get", tokens_key))
if last_tokens == nil then
    last_tokens = capacity
end
--redis.log(redis.LOG_WARNING, "last_tokens " .. last_tokens)

local last_refreshed = tonumber(redis.call("get", timestamp_key))
if last_refreshed == nil then
    last_refreshed = 0
end
--redis.log(redis.LOG_WARNING, "last_refreshed " .. last_refreshed)

local delta = math.max(0, now-last_refreshed)
local filled_tokens = math.min(capacity, last_tokens+(delta*rate))
local allowed = filled_tokens >= requested
local new_tokens = filled_tokens
local allowed_num = 0
if allowed then
    new_tokens = filled_tokens - requested
    allowed_num = 1
end

--redis.log(redis.LOG_WARNING, "delta " .. delta)
--redis.log(redis.LOG_WARNING, "filled_tokens " .. filled_tokens)
--redis.log(redis.LOG_WARNING, "allowed_num " .. allowed_num)
--redis.log(redis.LOG_WARNING, "new_tokens " .. new_tokens)

if ttl > 0 then
    redis.call("setex", tokens_key, ttl, new_tokens)
    redis.call("setex", timestamp_key, ttl, now)
end

-- return { allowed_num, new_tokens, capacity, filled_tokens, requested, new_tokens }
return { allowed_num, new_tokens }

```

成杰

```lua
--
-- Created by IntelliJ IDEA.
-- User: crossoverJie
-- Date: 22/04/2018
-- Time: 15:36
-- To change this template use File | Settings | File Templates.
--
--lua 下标从 1 开始
-- 限流 key
local key = KEYS[1]
-- 限流大小
local limit = tonumber(ARGV[1])

-- 获取当前流量大小
local curentLimit = tonumber(redis.call('get', key) or "0")

if curentLimit + 1 > limit then
    -- 达到限流大小 返回
    return 0;
else
    -- 没有达到阈值 value + 1
    redis.call("INCRBY", key, 1)
    redis.call("EXPIRE", key, 2)
    return curentLimit + 1
end
```


## Redis和Lua实现分布式限流器的方法详解

原文连接：https://www.h5w3.com/254282.html

主要是依靠 redis + lua 来实现限流器, 使用 lua 的原因是将多条命令合并在一起作为一个原子操作, 无需过多考虑并发.

### 计数器模式

原理

计数器算法是指在一段窗口时间内允许通过的固定数量的请求, 比如10次/秒, 500次/30秒.

如果设置的时间粒度越细, 那么限流会更平滑.

实现

所使用的 Lua 脚本

```lua
-- 计数器限流

-- 此处支持的最小单位时间是秒, 若将 expire 改成 pexpire 则可支持毫秒粒度.

-- KEYS[1] string 限流的key

-- ARGV[1] int  限流数

-- ARGV[2] int  单位时间(秒)

local cnt = tonumber(redis.call("incr", KEYS[1]))

if (cnt == 1) then

 -- cnt 值为1说明之前不存在该值, 因此需要设置其过期时间

 redis.call("expire", KEYS[1], tonumber(ARGV[2]))

elseif (cnt > tonumber(ARGV[1])) then

 return -1

end 

return cnt
```

返回 -1 表示超过限流, 否则返回当前单位时间已通过的请求数

key 可以但不限于以下的情况

ip + 接口
user_id + 接口
优点

实现简单
缺点

粒度不够细的情况下, 会出现在同一个窗口时间内出现双倍请求数

注意

尽量保持时间粒度精细
场景分析

eg. 1000/3s 的限流

极端情况1:

第1秒请求数 10

第2秒请求数 10

第3秒请求数 980

第4秒请求数 900

第5秒请求数 100

第6秒请求数 0

此时注意第3~5秒内的总请求数高达 1980

极端情况2:

第1秒请求数 1000

第2秒请求数 0

第3秒请求数 0

此时后续的第2~3秒会出现大量拒绝请求

### 令牌桶模式

令牌桶的桶中保存有令牌, 存在上限, 且一开始是满的,每次请求都要消耗令牌(可根据不同请求消耗不同数量的令牌)

每隔一段时间(固定速率)会往桶中放令牌

桶的实现还分为:

可预消费

提前预支令牌数: 前人挖坑, 后人跳

不可预消费

令牌数不够直接拒绝

实现

此处实现的不可预消费的令牌桶, 具体Lua代码:

```lua
-- 令牌桶限流: 不支持预消费, 初始桶是满的

-- KEYS[1] string 限流的key

-- ARGV[1] int  桶最大容量

-- ARGV[2] int  每次添加令牌数

-- ARGV[3] int  令牌添加间隔(秒)

-- ARGV[4] int  当前时间戳

local bucket_capacity = tonumber(ARGV[1])

local add_token = tonumber(ARGV[2])

local add_interval = tonumber(ARGV[3])

local now = tonumber(ARGV[4])

-- 保存上一次更新桶的时间的key

local LAST_TIME_KEY = KEYS[1].."_time";   

-- 获取当前桶中令牌数

local token_cnt = redis.call("get", KEYS[1]) 

-- 桶完全恢复需要的最大时长

local reset_time = math.ceil(bucket_capacity / add_token) * add_interval;

if token_cnt then -- 令牌桶存在

 -- 上一次更新桶的时间

 local last_time = redis.call('get', LAST_TIME_KEY)

 -- 恢复倍数

 local multiple = math.floor((now - last_time) / add_interval)

 -- 恢复令牌数

 local recovery_cnt = multiple * add_token

 -- 确保不超过桶容量

 local token_cnt = math.min(bucket_capacity, token_cnt + recovery_cnt) - 1

 if token_cnt < 0 then

  return -1;

 end

 -- 重新设置过期时间, 避免key过期

 redis.call('set', KEYS[1], token_cnt, 'EX', reset_time)      

 redis.call('set', LAST_TIME_KEY, last_time + multiple * add_interval, 'EX', reset_time)

 return token_cnt

else -- 令牌桶不存在

 token_cnt = bucket_capacity - 1

 -- 设置过期时间避免key一直存在

 redis.call('set', KEYS[1], token_cnt, 'EX', reset_time);

 redis.call('set', LAST_TIME_KEY, now, 'EX', reset_time + 1); 

 return token_cnt 

end
```

令牌桶的关键是以下几个参数:

桶最大容量
每次放入的令牌数
放入令牌的间隔时间
令牌桶的实现不会出现计数器模式中单位时间内双倍流量的问题.