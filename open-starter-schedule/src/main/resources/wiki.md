# 从定时任务说起

自然界中定时任务无处不在，太阳每天东升西落，候鸟的迁徙，树木的年轮，人们每天按时上班，每个月按时发工资、交房租，四季轮换，潮涨潮落，等等，从某种意义上说，都可以认为是定时任务。

# 定时任务的实现方式有哪些？

在日常工作中，想要实现定时任务我们通常是直接使用java自带的工具类，如Timer、 ScheduledThreadPoolExecutor等方法 ，复杂的一些场景用开源工具包Quartz

## 使用 Timer 实现定时任务

使用 Timer 每秒执行一次任务

```java
public class ScheduleTest {

   public static void main(String[] args) {
      Timer timer = new Timer();
      timer.schedule(new TimerTask() {
         public void run() {
            System.out.println("任务执行了");
         }
      }, 0, 1000);
   }
}
```

缺点：Timer是单线程的会有任务阻塞的风险,并且对异常没有做处理,一个任务出错Timer就挂了。

具体原理后续补充

## 使用 ScheduledThreadPoolExecutor 实现定时任务

使用 ScheduledThreadPoolExecutor 每秒执行一次任务

```java
public class ScheduleTest {

    public static void main(String[] args) {
        ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(5);
        executorService.scheduleAtFixedRate(() -> {
            System.out.println("任务执行了，线程名:" + Thread.currentThread().getName());
        }, 0, 1000, TimeUnit.MILLISECONDS);

    }
}
```

ScheduledThreadPool相比于Timer引入了线程池，并且线程池对异常做了处理，使得任务之间不会有影响。

具体原理后续补充

## 基于时间轮的定时任务

1. 时间轮算法

从时间维度可以分为定时或者延迟一定时间两个维度，而时间轮就是一种高效的利用线程资源来进行批量化调度的一种调度模型，

把大批量的调度任务全部都绑定到同一个的调度器上面，使用这一个调度器来进行所有任务的管理，触发以及运行，能够高效的管理各种延时任务，周期任务。

我只需要把任务放到它需要被执行的时刻，然后等着时针转到这个时刻时，取出该时刻放置的任务，执行就可以了，这就是时间轮算法最核心的思想了。
 
2. 时间轮的数据结构

首先，时钟可以用数组或者循环链表表示，这个每个时钟的刻度就是一个槽，槽位本身也指代时间精度，比如一秒扫一个槽，那么这个时间轮的最高精度就是 1 秒。

也就是说延迟 1.2 秒的任务和 1.5 秒的任务会被加入到同一个槽中，槽用来存放该刻度需要执行的任务，如果有多个任务需要执行呢？每个槽里面放一个链表就可以了

同一时刻存在多个任务时，只要把该刻度对应的链表全部遍历一遍，执行（扔到线程池中异步执行）其中的任务即可。

3. 时间刻度不够用怎么办？

如果任务不只限定在一天之内呢？比如我有个任务，需要每周一上午九点执行，我还有另一个任务，需要每周三的上午九点执行。一种很容易想到的解决办法是：

> 1.增大时间轮的刻度

一天24个小时，一周168个小时，为了解决上面的问题，我可以把时间轮的刻度（槽）从12个增加到168个，比如现在是星期二上午10点钟，那么下周一上午九点就是时间轮的第9个刻度，这周三上午九点就是时间轮的第57个刻度

仔细思考一下，会发现这中方式存在几个缺陷：

- 时间刻度太多会导致时间轮走到的多数刻度没有任务执行，比如一个月就2个任务，我得移动720次，其中718次是无用功。

- 时间刻度太多会导致存储空间变大，利用率变低，比如一个月就2个任务，我得需要大小是720的数组，如果我的执行时间的粒度精确到秒，那就更恐怖了。

于是乎，聪明的你脑袋一转，想到另一个办法：

> 2.列表中的任务中添加round属性

这次我不增加时间轮的刻度了，刻度是 24 个，现在有三个任务需要执行，

1. 任务一: 每周二上午九点。

2. 任务二: 每周四上午九点。

3. 任务三: 每个月12号上午九点。

比如现在是 9月11号星期二上午10点，时间轮转一圈是24小时，到任务一下次执行（下周二上午九点）,需要时间轮转过6圈后，到第7圈的第9个刻度开始执行。

任务二下次执行第3圈的第9个刻度，任务三是第2圈的第9个刻度。

时间轮每移动到一个刻度时，遍历任务列表，把round值-1，然后取出所有round=0的任务执行。

这样做能解决时间轮刻度范围过大造成的空间浪费，但是却带来了另一个问题：

时间轮每次都需要遍历任务列表，耗时增加，当时间轮刻度粒度很小(秒级甚至毫秒级)，任务列表又特别长时，这种遍历的办法是不可接受的。

当然，对于大多数场景，这种方法还是适用的。

有没有既节省空间，又节省时间的办法呢？采用分层时间轮

> 3.分层时间轮

分层时间轮是这样一种思想：

1. 针对时间复杂度的问题：不做遍历计算round，凡是任务列表中的都应该是应该被执行的，直接全部取出来执行。

2. 针对空间复杂度的问题：分层，每个时间粒度对应一个时间轮，多个时间轮之间进行级联协作。

第一点很好理解，第二点有必要举个例子来说明：

比如我有三个任务：

任务一：每周二上午九点。

任务二：每周四上午九点。

任务三：每个月12号上午九点。

三个任务涉及到四个时间单位：小时、天、星期、月份。

拿任务三来说，任务三得到执行的前提是，时间刻度先得来到12号这一天，然后才需要关注其更细一级的时间单位：上午9点。

基于这个思想，我们可以设置三个时间轮：月轮、周轮、天轮。

月轮的时间刻度是天。

周轮的时间刻度是天。

天轮的时间刻度是小时。

初始添加任务时，任务一添加到天轮上，任务二添加到周轮上，任务三添加到月轮上。

三个时间轮以各自的时间刻度不停流转。

当周轮移动到刻度2(星期二)时，取出这个刻度下的任务，丢到天轮上，天轮接管该任务，到9点执行。

同理，当月轮移动到刻度12(12号)时，取出这个刻度下的任务，丢到天轮上，天轮接管该任务，到9点执行。

这样就可以做到既不浪费空间，有不浪费时间。

## 时间轮算法的应用

时间轮的思想应用范围非常广泛，各种操作系统的定时任务调度，Crontab, 还有 Netty、Kafka 中也有时间轮的实现，几乎所有的时间任务调度系统采用的都是时间轮的思想。

至于采用 round 型的时间轮还是采用分层时间轮，看实际需要吧，时间复杂度和实现复杂度的取舍。

## 总结

Timer、DelayQueue 和 ScheduledThreadPool，它们都是基于优先队列实现的，O(logn) 的时间复杂度在任务数多的情况下频繁的插入、删除操作有性能问题，因此适合于任务数不多的情况。

1. Timer是单线程的会有任务阻塞的风险,并且对异常没有做处理,一个任务出错Timer就挂了。

2. ScheduledThreadPool相比于Timer引入了线程池，并且线程池对异常做了处理，使得任务之间不会有影响。

3. Timer和ScheduledThreadPool可以周期性执行任务，DelayQueue就是个具有优先级的阻塞队列，需要配合外部的工作线程使用。

时间轮的实现类似钟表的运作方式，它的任务插入和删除时间复杂度都为O(1)，相对而言时间轮更适合任务数很大的延时场景。

1. 对于延迟超过时间轮所能表示的范围有两种处理方式，一是通过增加一个字段-轮数（Netty），二是多层次时间轮（Kakfa）。

2. 相比而言Netty的实现会有空推进的问题，而Kafka采用DelayQueue来保存有任务数据的槽，利用空间换时间的思想解决了空推进的问题。


参考链接：https://blog.csdn.net/xinzhongtianxia/article/details/86221241