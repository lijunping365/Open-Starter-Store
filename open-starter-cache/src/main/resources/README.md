# 分布式缓存

## 开篇

一级缓存是应用内缓存，二级缓存是比一级缓存更大的一个容器，它是应用集群获取缓存数据的统一载体。

二级缓存存在的意义就是如果二级缓存中有数据，集群中任一节点在本地缓存中没获取到数据的时候可以从二级缓存中直接获取到数据而不用查询数据库。

**总结**：进程内缓存做为一级缓存，分布式缓存做为二级缓存，首先从一级缓存中查询，若能查询到数据则直接返回，

否则从二级缓存中查询，若二级缓存中可以查询到数据，则回填到一级缓存中，并返回数据。

若二级缓存也查询不到，则从数据源中查询，将结果分别回填到一级缓存，二级缓存中。

因此，我们非常有必要使用二级缓存在集群模式下。

## 缓存的有界和无界

有界的缓存我们可以留下更多的空间和资源给服务器，让其处理的更快，因此我们需要使我们的缓存变成有界的。

我们需要提供一些驱逐策略来使缓存占用的空间在一个合理的范围内

## 多个应用使用统一的可视化程序进行管理

假设我们有用户系统，有订单系统... 这些系统都是集群模式，我们需要使用一个统一的可视化程序进行管理这些系统的缓存

1. 可以通过该程序手动清除某个系统的某个缓存
2. 可以查看各个系统的缓存的命中率... 参数
3. ...

## 架构设计

### 思考

1. 前几天在准备做二级缓存的时候，就在想如果一级缓存里面有数据，还要二级缓存干啥？ 首先为什么要用缓存？

不就是因为我们数据库压力太大了嘛，查询太慢了嘛，好办！我们给他加个缓存，为了尽量减轻服务器内存的压力，我们可以先加一个 redis 缓存，后来发现请求全跑到 redis 上了，

redis 压力也很大， redis 也快扛不住了，我们为了减轻 redis 的压力，这个时候没办法了，我们必须要加一个本地缓存，占用服务器的一部分内存来做缓存，来减轻 redis 的压力，即一部分数据走本地缓存，一部分数据走 redis 缓存

分流思想。

因此，我们的就设计了这样一个二级缓存结构： 

第一级缓存是：Caffeine , 第二级缓存是：Redisson。

二级缓存，我们使用Redisson对Spring Cache的扩展类RedissonCache 。它的底层是RMap，底层存储是Hash。

2. 考虑完第一个问题之后一直在考虑 spring cache 为什么要设计 CacheManager

看了 CacheManager 的实现之一 CaffeineCacheManager，里面有 private final ConcurrentMap<String, Cache> cacheMap = new ConcurrentHashMap(16);

我知道一个 cacheName 对应一个 Cache， cacheName 对应一个分类数据， 比如有个 cacheName 叫 book，那 这个 book 缓存的数据都是 book 相关的，cat 缓存的数据都是与 cat 相关的，

后来发现他是要实现一个类似 redis 中 hash 的一个结构，Map<key(indexName), Map<hashKey(就是我们缓存注解设置的 key), value(就是 key 对应的数据)>>，这样设计的确实更加方便操作

因为我一开始想把 CacheManager 去掉，直接用 Map 去存所有的数据，Map key 就是 cacheName + cacheKey 组合，Map value 就是数据，这样操作起来确实很麻烦，

有了 CacheManager 我们就可以像操作 redis 的 Hash 一样操作我我们的缓存了，

     那有了这个理解，我们在看下 CacheManager 的另一个实现 RedisCacheManager，里面没有 Map<String, Map<String,Object> 的结构，因为我们知道 redis 就有 hash 这种数据结构，

    而且我们发现 RedisCacheManager 有 private final Map<String, RedisCacheConfiguration> initialCacheConfiguration; RedisCacheConfiguration 就代表 Cache 的一些配置

我们再看下 CacheManager 的另一个实现 RedissonSpringCacheManager 里面有 ConcurrentMap<String, Cache> instanceMap = new ConcurrentHashMap<String, Cache>(); 

而且我们的一个 Cacheable 注解就代表一个 Cache

但是我们关于 Cache 的配置，比如某个 Cache 的最大缓存数量，过期时间... 我们这里既然是二级缓存，应该有一个统一配置中心去管理这个配置，虽然 caffeine 和 redis 都支持这些配置，但是不如统一管理

但是我们又考虑到一二级缓存的配置不一定都要一致，比如最大缓存数量，我们本地可能会配置的稍微小些，但是我们 redis 可以配置的稍微大些，这样当本地缓存失效之后可以从二级缓存拿到数据就不需要跑数据库去拿。

3. 考虑一二级缓存的配置是否要一致


**「查询」数据的流程**：

先从本地缓存中查询数据，若能查询到，直接返回；

本地缓存查询不到数据，查询分布式缓存，若可以查询出来，回填到本地缓存，并返回；

若分布式缓存查询不到数据，则默认会执行被注解的方法。


## 二级缓存需要考虑的点还很多

### 1.如何保证分布式节点一级缓存的一致性？

我们说一级缓存是应用内缓存，那么当你的项目部署在多个节点的时候，如何保证当你对某个key进行修改删除操作时，使其它节点的一级缓存一致呢？

### 2.是否允许存储空值？

这个确实是需要考虑的点。因为如果某个查询缓存和数据库中都没有，那么就会导致频繁查询数据库，导致数据库Down,这也是我们常说的缓存穿透。

但如果存储空值呢，因为可能会存储大量的空值，导致缓存变大，所以这个最好是可配置，按照业务来决定是否开启。

### 3.是否需要缓存预热？

也就是说，我们会觉得某些key一开始就会非常的热，也就是热点数据，那么我们是否可以一开始就先存储到缓存中，避免缓存击穿。

### 4.一级缓存存储数量上限的考虑？

既然一级缓存是应用内缓存，那你是否考虑一级缓存存储的数据给个限定最大值，避免存储太多的一级缓存导致OOM。

### 5.一级缓存过期策略的考虑？

我们说redis作为二级缓存，redis是淘汰策略来管理的。具体可参考redis的8种淘汰策略。那你的一级缓存策略呢？就好比你设置一级缓存

数量最大为5000个,那当第5001个进来的时候，你是怎么处理呢？是直接不保存，还是说自定义LRU或者LFU算法去淘汰之前的数据？

### 6.一级缓存过期了如何清除？

我们说redis作为二级缓存，我们有它的缓存过期策略(定时、定期、惰性)，那你的一级缓存呢，过期如何清除呢？

这里4、5、6小点如果说用我们传统的Map显然实现是很费劲的，但现在有更好用的一级缓存库那就是Caffeine。

### 7. 缓存 item和缓存list的时候，更希望取列表时按item缓存

缓存 item和缓存list的时候，更希望取列表时按item缓存，因为可能列表和详情的字段内容是一样的，列表和详情在内存上重复了，造成了内存的浪费


https://www.cnblogs.com/makemylife/p/15796265.html







































